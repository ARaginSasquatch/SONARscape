<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SONARScape: Captain Sonar Interface</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/babel-standalone@6.26.0/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-800 text-white">
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Shared chat state
    const initialChatMessages = [];
    let sharedChatMessages = initialChatMessages;

    // ChatBox component
    const ChatBox = () => {
      const [message, setMessage] = useState('');
      const [messages, setMessages] = useState(sharedChatMessages);

      useEffect(() => {
        setMessages(sharedChatMessages);
      }, []);

      const sendMessage = () => {
        if (message.trim()) {
          sharedChatMessages = [...sharedChatMessages, { text: message, id: Date.now() }];
          setMessages(sharedChatMessages);
          setMessage('');
        }
      };

      return (
        <div class="bg-gray-700 p-4 rounded-lg shadow-lg w-full max-w-md">
          <h3 class="text-lg font-bold mb-2">Team Chat</h3>
          <div class="h-40 overflow-y-auto mb-2 bg-gray-800 p-2 rounded">
            {messages.map((msg) => (
              <p key={msg.id} class="text-sm">{msg.text}</p>
            ))}
          </div>
          <div class="flex">
            <input
              type="text"
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              class="flex-1 p-2 rounded-l bg-gray-600 text-white"
              placeholder="Type a message..."
            />
            <button
              onClick={sendMessage}
              class="p-2 bg-blue-600 rounded-r hover:bg-blue-700"
            >
              Send
            </button>
          </div>
        </div>
      );
    };

    // Captain Interface
    const CaptainInterface = ({ team, gameState, updateGameState }) => {
      const gridSize = 15;
      const islands = [
        { x: 3, y: 3 }, { x: 3, y: 11 }, { x: 11, y: 3 }, { x: 11, y: 11 }
      ];

      const getSector = (x, y) => {
        const sectorX = Math.floor(x / 5);
        const sectorY = Math.floor(y / 5);
        return sectorY * 3 + sectorX + 1;
      };

      const isValidMove = (x, y) => {
        return (
          x >= 0 &&
          x < gridSize &&
          y >= 0 &&
          y < gridSize &&
          !islands.some((i) => i.x === x && i.y === y) &&
          !gameState.path.some((p) => p.x === x && p.y === y)
        );
      };

      const move = (direction) => {
        if (gameState.isSurfacing) {
          alert('Cannot move while surfacing!');
          return;
        }
        const { x, y } = gameState.position;
        let newX = x;
        let newY = y;
        if (direction === 'N') newY--;
        else if (direction === 'S') newY++;
        else if (direction === 'E') newX++;
        else if (direction === 'W') newX--;

        if (isValidMove(newX, newY)) {
          const newPosition = { x: newX, y: newY };
          updateGameState({
            position: newPosition,
            path: [...gameState.path, newPosition],
            sector: getSector(newX, newY)
          });
          alert(`${team} moved ${direction}!`);
        } else {
          alert('Invalid move: Blocked by path or island!');
        }
      };

      const surface = () => {
        if (gameState.isSurfacing) {
          alert('Already surfacing!');
          return;
        }
        if (Object.values(gameState.breakdowns).some((b) => b)) {
          alert('Cannot surface: Engineer must repair all breakdowns!');
          return;
        }
        updateGameState({ isSurfacing: true });
        alert(`${team} is surfacing!`);
      };

      const completeSurfacing = () => {
        updateGameState({
          path: [gameState.position],
          isSurfacing: false,
          breakdowns: {
            north: idiom: I'm all ears! If you've got any tweaks, specific rulebook pages, or extra features (like damage tracking or fancier visuals), just let me know, and I'll dive right in. What's next?
