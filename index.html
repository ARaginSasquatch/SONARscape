<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SONARScape: Team A Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/babel-standalone@6.26.0/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body className="bg-gray-800 text-white">
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useReducer } = React;

    // Persistent shared game state
    const initialSharedState = {
      teamA: { position: { x: 7, y: 7 }, damage: 0 },
      teamB: { position: { x: 7, y: 7 }, damage: 0 },
      chatMessages: []
    };
    window.sharedState = window.sharedState || { ...initialSharedState };

    // Game state reducer
    const initialGameState = {
      position: { x: 7, y: 7 },
      path: [{ x: 7, y: 7 }],
      mines: [],
      systems: { torpedo: 0, mine: 0, drone: 0, sonar: 0, silence: 0 },
      breakdowns: {
        north: [false, false, false, false],
        south: [false, false, false, false],
        east: [false, false, false, false],
        west: [false, false, false, false],
        green: [false, false],
        orange: [false, false]
      },
      isSurfacing: false,
      sector: 5,
      selectedSystem: 'torpedo'
    };

    const systemsConfig = {
      torpedo: { max: 2 },
      mine: { max: 1 },
      drone: { max: 2 },
      sonar: { max: 1 },
      silence: { max: 3 }
    };

    const sectorBreakdowns = {
      1: 'north', 2: 'south', 3: 'east', 4: 'west', 5: 'green', 6: 'orange', 7: 'north', 8: 'south', 9: 'east'
    };

    // Generate islands once
    const generateIslands = () => {
      const gridSize = 15;
      const shapes = [
        [[0,0]], // Single cell
        [[0,0], [0,1]], // 2-cell vertical
        [[0,0], [1,0]], // 2-cell horizontal
        [[0,0], [0,1], [1,0]], // L-shape
        [[0,0], [0,1], [1,0], [1,1]], // 2x2 square
        [[0,0], [0,1], [0,2]], // 3-cell vertical
        [[0,0], [1,0], [2,0]], // 3-cell horizontal
        [[0,0], [0,1], [1,0], [0,-1]], // Cross
      ];
      const islands = [];
      const numIslands = Math.floor(Math.random() * 4) + 5; // 5‚Äì8 islands
      const occupied = new Set(['7,7']); // Protect starting position

      for (let i = 0; i < numIslands; i++) {
        let placed = false;
        let attempts = 0;
        while (!placed && attempts < 50) {
          const shape = shapes[Math.floor(Math.random() * shapes.length)];
          const anchorX = Math.floor(Math.random() * gridSize);
          const anchorY = Math.floor(Math.random() * gridSize);
          let valid = true;
          const cells = [];

          for (const [dx, dy] of shape) {
            const x = anchorX + dx;
            const y = anchorY + dy;
            if (
              x < 0 || x >= gridSize ||
              y < 0 || y >= gridSize ||
              occupied.has(`${x},${y}`)
            ) {
              valid = false;
              break;
            }
            cells.push({ x, y });
          }

          if (valid) {
            cells.forEach(cell => occupied.add(`${cell.x},${cell.y}`));
            islands.push(...cells);
            placed = true;
          }
          attempts++;
        }
      }
      return islands;
    };

    window.islands = window.islands || generateIslands();

    const gameReducer = (state, action) => {
      const gridSize = 15;
      const islands = window.islands;

      switch (action.type) {
        case 'MOVE':
          if (state.isSurfacing) return state;
          const { x, y } = state.position;
          let newX = x;
          let newY = y;
          if (action.direction === 'N') newY--;
          else if (action.direction === 'S') newY++;
          else if (action.direction === 'E') newX++;
          else if (action.direction === 'W') newX--;

          if (
            newX >= 0 && newX < gridSize &&
            newY >= 0 && newY < gridSize &&
            !islands.some(i => i.x === newX && i.y === newY) &&
            !state.path.some(p => p.x === newX && p.y === newY)
          ) {
            const newPosition = { x: newX, y: newY };
            const sector = Math.floor(newY / 5) * 3 + Math.floor(newX / 5) + 1;
            const system = sectorBreakdowns[sector] || 'north';
            const breakdowns = { ...state.breakdowns };
            const systemBreakdowns = [...breakdowns[system]];
            const nextFalseIndex = systemBreakdowns.indexOf(false);
            if (nextFalseIndex !== -1) systemBreakdowns[nextFalseIndex] = true;
            breakdowns[system] = systemBreakdowns;

            window.sharedState[action.team] = { ...window.sharedState[action.team], position: newPosition };
            return {
              ...state,
              position: newPosition,
              path: [...state.path, newPosition],
              sector,
              breakdowns,
              systems: {
                ...state.systems,
                [state.selectedSystem]: Math.min(state.systems[state.selectedSystem] + 1, systemsConfig[state.selectedSystem].max)
              }
            };
          }
          return state;

        case 'SURFACE':
          if (state.isSurfacing || Object.values(state.breakdowns).some(arr => arr.some(b => b))) return state;
          return { ...state, isSurfacing: true };

        case 'COMPLETE_SURFACING':
          return {
            ...state,
            path: [state.position],
            isSurfacing: false,
            breakdowns: {
              north: [false, false, false, false],
              south: [false, false, false, false],
              east: [false, false, false, false],
              west: [false, false, false, false],
              green: [false, false],
              orange: [false, false]
            }
          };

        case 'USE_SYSTEM':
          if (state.isSurfacing || state.systems[action.system] < systemsConfig[action.system].max) return state;
          let newState = { ...state, systems: { ...state.systems, [action.system]: 0 } };
          const enemyTeam = action.team === 'teamA' ? 'teamB' : 'teamA';
          const enemyPos = window.sharedState[enemyTeam] && window.sharedState[enemyTeam].position 
            ? window.sharedState[enemyTeam].position 
            : { x: 0, y: 0 };

          if (action.system === 'torpedo') {
            const { x, y } = action.target;
            if (x >= 0 && x < 15 && y >= 0 && y < 15) {
              const dist = Math.abs(state.position.x - x) + Math.abs(state.position.y - y);
              if (dist <= 2) {
                const isDirect = x === enemyPos.x && y === enemyPos.y;
                const damage = isDirect ? 2 : (dist === 1 || dist === 2) && (Math.abs(x - enemyPos.x) + Math.abs(y - enemyPos.y) <= 1) ? 1 : 0;
                if (damage > 0 && window.sharedState[enemyTeam]) {
                  window.sharedState[enemyTeam] = {
                    ...window.sharedState[enemyTeam],
                    damage: Math.min(window.sharedState[enemyTeam].damage + damage, 4)
                  };
                }
                return newState;
              }
            }
          } else if (action.system === 'mine') {
            newState.mines = [...state.mines, { ...state.position, id: Date.now() }];
            return newState;
          } else if (action.system === 'drone') {
            const sector = action.sector;
            const enemySector = Math.floor(enemyPos.y / 5) * 3 + Math.floor(enemyPos.x / 5) + 1;
            if (sector === enemySector) {
              alert('Enemy detected in sector!');
            } else {
              alert('No enemy in sector.');
            }
            return newState;
          } else if (action.system === 'sonar') {
            const choice = Math.random() < 0.33 ? 'row' : Math.random() < 0.5 ? 'column' : 'sector';
            const value = choice === 'row' ? enemyPos.y : choice === 'column' ? enemyPos.x : Math.floor(enemyPos.y / 5) * 3 + Math.floor(enemyPos.x / 5) + 1;
            window.sharedState.chatMessages = [...window.sharedState.chatMessages, { text: `${enemyTeam} reveals ${choice}: ${value}`, id: Date.now() }];
            return newState;
          } else if (action.system === 'silence') {
            // Silence: Move 0‚Äì4 spaces without announcing to enemy (no chatMessages update)
            let tempState = { ...state };
            for (const move of action.moves) {
              let newX = tempState.position.x;
              let newY = tempState.position.y;
              if (move === 'N') newY--;
              else if (move === 'S') newY++;
              else if (move === 'E') newX++;
              else if (move === 'W') newX--;
              if (
                newX >= 0 && newX < gridSize &&
                newY >= 0 && newY < gridSize &&
                !islands.some(i => i.x === newX && i.y === newY) &&
                !tempState.path.some(p => p.x === newX && p.y === newY)
              ) {
                tempState.position = { x: newX, y: newY };
                tempState.path = [...tempState.path, { x: newX, y: newY }];
                window.sharedState[action.team] = { ...window.sharedState[action.team], position: { x: newX, y: newY } };
              } else {
                return state; // Invalid move, abort silence
              }
            }
            return { ...tempState, systems: { ...tempState.systems, silence: 0 } };
          }
          return newState;

        case 'DETONATE_MINE':
          const mine = state.mines.find(m => m.id === action.mineId);
          if (mine) {
            const enemyTeam = action.team === 'teamA' ? 'teamB' : 'teamA';
            const enemyPos = window.sharedState[enemyTeam] && window.sharedState[enemyTeam].position 
              ? window.sharedState[enemyTeam].position 
              : { x: 0, y: 0 };
            const dist = Math.abs(mine.x - enemyPos.x) + Math.abs(mine.y - enemyPos.y);
            const damage = dist === 0 ? 2 : dist === 1 ? 1 : 0;
            if (damage > 0 && window.sharedState[enemyTeam]) {
              window.sharedState[enemyTeam] = {
                ...window.sharedState[enemyTeam],
                damage: Math.min(window.sharedState[enemyTeam].damage + damage, 4)
              };
            }
            return { ...state, mines: state.mines.filter(m => m.id !== action.mineId) };
          }
          return state;

        case 'SET_SELECTED_SYSTEM':
          return { ...state, selectedSystem: action.system };

        default:
          return state;
      }
    };

    // ChatBox component
    const ChatBox = () => {
      const [message, setMessage] = useState('');
      const [messages, setMessages] = useState(window.sharedState.chatMessages);

      useEffect(() => {
        const interval = setInterval(() => {
          setMessages([...window.sharedState.chatMessages]);
        }, 1000);
        return () => clearInterval(interval);
      }, []);

      const sendMessage = () => {
        if (message.trim()) {
          window.sharedState.chatMessages = [...window.sharedState.chatMessages, { text: message, id: Date.now() }];
          setMessages([...window.sharedState.chatMessages]);
          setMessage('');
        }
      };

      return (
        <div className="bg-gray-700 p-4 rounded-lg shadow-lg w-full max-w-md">
          <h3 className="text-lg font-bold mb-2">Team Chat</h3>
          <div className="h-40 overflow-y-auto mb-2 bg-gray-800 p-2 rounded">
            {messages.map((msg) => (
              <p key={msg.id} className="text-sm">{msg.text}</p>
            ))}
          </div>
          <div className="flex">
            <input
              type="text"
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              className="flex-1 p-2 rounded-l bg-gray-600 text-white"
              placeholder="Type a message..."
            />
            <button
              onClick={sendMessage}
              className="p-2 bg-blue-600 rounded-r hover:bg-blue-700"
            >
              Send
            </button>
          </div>
        </div>
      );
    };

    // Captain Interface
    const CaptainInterface = ({ team, state, dispatch }) => {
      const gridSize = 15;
      const islands = window.islands;

      const renderGrid = () => {
        const grid = [];
        for (let y = 0; y < gridSize; y++) {
          const row = [];
          for (let x = 0; x < gridSize; x++) {
            const isSub = x === state.position.x && y === state.position.y;
            const isPath = state.path.some(p => p.x === x && p.y === y && !(p.x === state.position.x && p.y === state.position.y));
            const isIsland = islands.some(i => i.x === x && i.y === y);
            const isMine = state.mines.some(m => m.x === x && m.y === y);
            const isSectorBorder = x % 5 === 0 || y % 5 === 0;
            row.push(
              <div
                key={`${x}-${y}`}
                className={`w-5 h-5 flex items-center justify-center text-xs border ${isSectorBorder ? 'border-gray-400' : 'border-gray-600'} ${
                  isSub ? 'bg-blue-600' : isIsland ? 'bg-gray-400' : isPath ? 'bg-gray-500' : isMine ? 'bg-red-600' : 'bg-gray-900'
                }`}
              >
                {isSub ? 'üö¢' : isIsland ? 'üèùÔ∏è' : isMine ? 'üí£' : isPath ? '¬∑' : ''}
              </div>
            );
          }
          grid.push(<div key={y} className="flex">{row}</div>);
        }
        return grid;
      };

      const move = (direction) => {
        dispatch({ type: 'MOVE', direction, team: team.toLowerCase().replace(' ', '') });
      };

      const surface = () => {
        dispatch({ type: 'SURFACE' });
      };

      const completeSurfacing = () => {
        dispatch({ type: 'COMPLETE_SURFACING' });
      };

      const useSystem = (system) => {
        if (system === 'torpedo') {
          const targetX = parseInt(prompt('Enter target X (0-14):') || '-1');
          const targetY = parseInt(prompt('Enter target Y (0-14):') || '-1');
          if (targetX >= 0 && targetX < 15 && targetY >= 0 && targetY < 15) {
            dispatch({ type: 'USE_SYSTEM', system, target: { x: targetX, y: targetY }, team: team.toLowerCase().replace(' ', '') });
            alert(`Torpedo fired at (${targetX}, ${targetY})!`);
          } else {
            alert('Invalid coordinates!');
          }
        } else if (system === 'mine') {
          dispatch({ type: 'USE_SYSTEM', system, team: team.toLowerCase().replace(' ', '') });
          alert('Mine dropped!');
        } else if (system === 'drone') {
          const sector = parseInt(prompt('Enter sector (1-9):') || '0');
          if (sector >= 1 && sector <= 9) {
            dispatch({ type: 'USE_SYSTEM', system, sector, team: team.toLowerCase().replace(' ', '') });
          } else {
            alert('Invalid sector!');
          }
        } else if (system === 'sonar') {
          dispatch({ type: 'USE_SYSTEM', system, team: team.toLowerCase().replace(' ', '') });
        } else if (system === 'silence') {
          const moves = (prompt('Enter silence moves (e.g., N,S,E,W):') || '').split(',').filter(m => ['N', 'S', 'E', 'W'].includes(m));
          if (moves.length <= 4) {
            dispatch({ type: 'USE_SYSTEM', system, moves, team: team.toLowerCase().replace(' ', '') });
            alert(`Silence activated: Moved [${moves.join(',') || 'none'}] without announcement!`);
          } else {
            alert('Too many moves (max 4)!');
          }
        }
      };

      const detonateMine = (mineId) => {
        dispatch({ type: 'DETONATE_MINE', mineId, team: team.toLowerCase().replace(' ', '') });
        alert('Mine detonated!');
      };

      return (
        <div className="bg-gray-700 p-4 rounded-lg shadow-lg">
          <h3 className="text-lg font-bold mb-2">{team} Captain</h3>
          <div className="mb-4">{renderGrid()}</div>
          <div className="flex space-x-2 mb-2">
            <button onClick={() => move('N')} className="p-2 bg-blue-600 rounded hover:bg-blue-700" disabled={state.isSurfacing}>North</button>
            <button onClick={() => move('S')} className="p-2 bg-blue-600 rounded hover:bg-blue-700" disabled={state.isSurfacing}>South</button>
            <button onClick={() => move('E')} className="p-2 bg-blue-600 rounded hover:bg-blue-700" disabled={state.isSurfacing}>East</button>
            <button onClick={() => move('W')} className="p-2 bg-blue-600 rounded hover:bg-blue-700" disabled={state.isSurfacing}>West</button>
          </div>
          <div className="flex space-x-2 mb-2">
            <button onClick={surface} className="p-2 bg-purple-600 rounded hover:bg-purple-700" disabled={state.isSurfacing || Object.values(state.breakdowns).some(arr => arr.some(b => b))}>Surface</button>
            {state.isSurfacing && (
              <button onClick={completeSurfacing} className="p-2 bg-green-600 rounded hover:bg-green-700">Complete Surfacing</button>
            )}
          </div>
          <div className="flex space-x-2 mb-2">
            {Object.keys(systemsConfig).map(system => (
              <button
                key={system}
                onClick={() => useSystem(system)}
                className={`p-2 rounded hover:bg-${system === 'torpedo' ? 'red' : system === 'mine' ? 'orange' : system === 'drone' ? 'yellow' : system === 'sonar' ? 'green' : 'purple'}-700 bg-${system === 'torpedo' ? 'red' : system === 'mine' ? 'orange' : system === 'drone' ? 'yellow' : system === 'sonar' ? 'green' : 'purple'}-600`}
                disabled={state.isSurfacing || state.systems[system] < systemsConfig[system].max}
              >
                {system.charAt(0).toUpperCase() + system.slice(1)}
              </button>
            ))}
          </div>
          {state.mines.length > 0 && (
            <div className="mt-2">
              <h4 className="text-sm font-bold">Mines:</h4>
              {state.mines.map(mine => (
                <button
                  key={mine.id}
                  onClick={() => detonateMine(mine.id)}
                  className="p-1 bg-red-600 rounded hover:bg-red-700 text-xs mr-1"
                >
                  Detonate ({mine.x}, {mine.y})
                </button>
              ))}
            </div>
          )}
          <div className="mt-2">
            <h4 className="text-sm font-bold">Damage: {window.sharedState[team.toLowerCase().replace(' ', '')] && window.sharedState[team.toLowerCase().replace(' ', '')].damage || 0}/4</h4>
          </div>
        </div>
      );
    };

    // First Mate Interface
    const FirstMateInterface = ({ team, state, dispatch }) => {
      const setSelectedSystem = (system) => {
        dispatch({ type: 'SET_SELECTED_SYSTEM', system });
      };

      return (
        <div className="bg-gray-700 p-4 rounded-lg shadow-lg">
          <h3 className="text-lg font-bold mb-2">{team} First Mate</h3>
          <div className="mb-2">
            <label className="mr-2">Charge System:</label>
            <select
              value={state.selectedSystem}
              onChange={(e) => setSelectedSystem(e.target.value)}
              className="p-1 bg-gray-600 rounded"
            >
              {Object.keys(systemsConfig).map(system => (
                <option key={system} value={system}>{system.charAt(0).toUpperCase() + system.slice(1)}</option>
              ))}
            </select>
          </div>
          <div className="space-y-2">
            {Object.keys(systemsConfig).map(system => (
              <div key={system} className="flex items-center">
                <span className="w-24 capitalize">{system}</span>
                <div className="flex-1 flex space-x-1">
                  {[...Array(systemsConfig[system].max)].map((_, i) => (
                    <div
                      key={i}
                      className={`w-6 h-6 border border-gray-500 ${i < state.systems[system] ? 'bg-green-600' : 'bg-gray-600'}`}
                    ></div>
                  ))}
                </div>
                <span className="ml-2">{state.systems[system]}/{systemsConfig[system].max}</span>
              </div>
            ))}
          </div>
        </div>
      );
    };

    // Engineer Interface
    const EngineerInterface = ({ team, state }) => {
      return (
        <div className="bg-gray-700 p-4 rounded-lg shadow-lg">
          <h3 className="text-lg font-bold mb-2">{team} Engineer</h3>
          <div className="grid grid-cols-4 gap-2">
            {Object.keys(state.breakdowns).map(system => (
              <div key={system} className="flex flex-col">
                <span className="capitalize text-sm mb-1">{system}</span>
                <div className="flex flex-col space-y-1">
                  {state.breakdowns[system].map((checked, i) => (
                    <input
                      key={i}
                      type="checkbox"
                      checked={checked}
                      onChange={() => {}}
                      className="w-5 h-5"
                      disabled
                    />
                  ))}
                </div>
              </div>
            ))}
          </div>
        </div>
      );
    };

    // Radio Operator Interface
    const RadioOperatorInterface = ({ team }) => {
      const gridSize = 15;
      const islands = window.islands;
      // Center overlay: 15x15 grid, each cell 20px (5px base + borders/padding), total 300px x 300px
      // Center at (7,7) by offsetting half the grid size (150px)
      const [overlayPos, setOverlayPos] = useState({ x: -150, y: -150 });
      const [isDragging, setIsDragging] = useState(false);
      const [currentPos, setCurrentPos] = useState({ x: 7, y: 7 }); // Start at center
      const [markedTiles, setMarkedTiles] = useState([{ x: 7, y: 7 }]); // Initial mark at center
      const [enemyMoves, setEnemyMoves] = useState([]); // Log of moves
      const [sectorGuess, setSectorGuess] = useState('');

      const addMove = (move) => {
        // Update current position and mark tile
        let newX = currentPos.x;
        let newY = currentPos.y;
        if (move === 'North') newY--;
        else if (move === 'South') newY++;
        else if (move === 'East') newX++;
        else if (move === 'West') newX--;
        if (newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize) {
          setCurrentPos({ x: newX, y: newY });
          setMarkedTiles(prev => [...prev, { x: newX, y: newY }]);
          setEnemyMoves(prev => [...prev, move]);
        } else {
          alert('Move out of bounds!');
        }
      };

      const guessSector = () => {
        if (sectorGuess >= 1 && sectorGuess <= 9) {
          alert(`Guessed enemy in sector ${sectorGuess}!`);
          setSectorGuess('');
        } else {
          alert('Invalid sector!');
        }
      };

      const handleMouseDown = () => {
        setIsDragging(true);
      };

      const handleMouseUp = () => {
        setIsDragging(false);
      };

      const handleMouseMove = (e) => {
        if (isDragging) {
          setOverlayPos(prev => ({
            x: prev.x + e.movementX,
            y: prev.y + e.movementY
          }));
        }
      };

      const renderMap = () => {
        const grid = [];
        for (let y = 0; y < gridSize; y++) {
          const row = [];
          for (let x = 0; x < gridSize; x++) {
            const isIsland = islands.some(i => i.x === x && i.y === y);
            const isSectorBorder = x % 5 === 0 || y % 5 === 0;
            row.push(
              <div
                key={`${x}-${y}`}
                className={`w-5 h-5 flex items-center justify-center text-xs border ${isSectorBorder ? 'border-gray-400' : 'border-gray-600'} ${
                  isIsland ? 'bg-gray-400' : 'bg-gray-900'
                }`}
              >
                {isIsland ? 'üèùÔ∏è' : ''}
              </div>
            );
          }
          grid.push(<div key={y} className="flex">{row}</div>);
        }
        return grid;
      };

      const renderOverlay = () => {
        const grid = [];
        for (let y = 0; y < gridSize; y++) {
          const row = [];
          for (let x = 0; x < gridSize; x++) {
            const isMarked = markedTiles.some(m => m.x === x && m.y === y);
            const isCurrent = x === currentPos.x && y === currentPos.y;
            const isSectorBorder = x % 5 === 0 || y % 5 === 0;
            row.push(
              <div
                key={`${x}-${y}`}
                className={`w-5 h-5 border ${isSectorBorder ? 'border-gray-300' : 'border-gray-500'} ${
                  isCurrent ? 'bg-yellow-600' : isMarked ? 'bg-yellow-400' : 'bg-transparent'
                } opacity-50 flex items-center justify-center`}
              >
                {isCurrent ? 'üìç' : isMarked ? '¬∑' : ''}
              </div>
            );
          }
          grid.push(<div key={y} className="flex">{row}</div>);
        }
        return grid;
      };

      return (
        <div className="bg-gray-700 p-4 rounded-lg shadow-lg">
          <h3 className="text-lg font-bold mb-2">{team} Radio Operator</h3>
          <div className="relative mb-4" style={{ width: '300px', height: '300px' }}>
            {/* Map Layer */}
            <div className="absolute">{renderMap()}</div>
            {/* Overlay Layer */}
            <div
              className="absolute"
              style={{ transform: `translate(${overlayPos.x}px, ${overlayPos.y}px)`, cursor: isDragging ? 'grabbing' : 'grab' }}
              onMouseDown={handleMouseDown}
              onMouseUp={handleMouseUp}
              onMouseMove={handleMouseMove}
            >
              {renderOverlay()}
            </div>
          </div>
          <div className="bg-gray-800 p-2 rounded h-40 overflow-y-auto mb-2">
            {enemyMoves.map((move, index) => (
              <p key={index} className="text-sm">{move}</p>
            ))}
          </div>
          <div className="flex space-x-2 mb-2">
            <button onClick={() => addMove('North')} className="p-2 bg-blue-600 rounded hover:bg-blue-700">N</button>
            <button onClick={() => addMove('South')} className="p-2 bg-blue-600 rounded hover:bg-blue-700">S</button>
            <button onClick={() => addMove('East')} className="p-2 bg-blue-600 rounded hover:bg-blue-700">E</button>
            <button onClick={() => addMove('West')} className="p-2 bg-blue-600 rounded hover:bg-blue-700">W</button>
          </div>
          <div className="flex">
            <input
              type="number"
              value={sectorGuess}
              onChange={(e) => setSectorGuess(e.target.value)}
              className="p-2 bg-gray-600 rounded-l text-white w-20"
              placeholder="Sector (1-9)"
            />
            <button
              onClick={guessSector}
              className="p-2 bg-blue-600 rounded-r hover:bg-blue-700"
            >
              Guess Sector
            </button>
          </div>
        </div>
      );
    };

    // Team Dashboard
    const TeamDashboard = ({ team }) => {
      const [state, dispatch] = useReducer(gameReducer, initialGameState);
      const [sharedDamage, setSharedDamage] = useState(window.sharedState[team.toLowerCase().replace(' ', '')] && window.sharedState[team.toLowerCase().replace(' ', '')].damage || 0);

      useEffect(() => {
        const interval = setInterval(() => {
          setSharedDamage(window.sharedState[team.toLowerCase().replace(' ', '')] && window.sharedState[team.toLowerCase().replace(' ', '')].damage || 0);
        }, 1000);
        console.log(`${team} Dashboard rendered`, state);
        return () => clearInterval(interval);
      }, [state, team]);

      return (
        <div className="p-6 bg-gray-800 min-h-screen">
          <h1 className="text-2xl font-bold mb-4">{team} Dashboard</h1>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <CaptainInterface team={team} state={state} dispatch={dispatch} />
            <FirstMateInterface team={team} state={state} dispatch={dispatch} />
            <EngineerInterface team={team} state={state} />
            <RadioOperatorInterface team={team} />
          </div>
          <div className="mt-6">
            <ChatBox />
          </div>
        </div>
      );
    };

    // Error Boundary
    class ErrorBoundary extends React.Component {
      state = { hasError: false };

      static getDerivedStateFromError(error) {
        return { hasError: true };
      }

      render() {
        if (this.state.hasError) {
          return <h1 className="text-red-600">Something went wrong. Check console for details.</h1>;
        }
        return this.props.children;
      }
    }

    // Main App
    const App = () => {
      console.log('Rendering App component');
      return (
        <ErrorBoundary>
          <TeamDashboard team="Team A" />
        </ErrorBoundary>
      );
    };

    // Render the app with createRoot
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
    console.log('App rendered successfully');
  </script>
</body>
</html>
