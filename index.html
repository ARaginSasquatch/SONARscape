<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SONARScape Role Interface</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/babel-standalone@7.22.9/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 font-sans">
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect } = React;

    // Game State
    const initialState = {
      teams: {
        Trident: { xp: 0, points: 0, tilesCleared: 0, position: 'A1', health: 20, weaponsLevel: 0, detectionLevel: 0, stealthLevel: 0, stealthPoints: 0 },
        Harpoon: { xp: 0, points: 0, tilesCleared: 0, position: 'E4', health: 20, weaponsLevel: 0, detectionLevel: 0, stealthLevel: 0, stealthPoints: 0 }
      },
      tasks: [],
      players: {},
      timer: { minutes: 10, seconds: 0, phase: 'Planning' },
      messages: []
    };

    // Task List
    const taskList = [
      { tile: 'Abyssal Sire', task: 'Bludgeon piece', points: 10, xp: 5000, type: 'boss', cap: 3 },
      { tile: 'Abyssal Sire', task: 'Orphan pet', points: 25, xp: 10000, type: 'boss', cap: 3 },
      { tile: 'Abyssal Sire', task: 'Unsired', points: 5, xp: 5000, type: 'boss', cap: 3 },
      { tile: 'Theatre of Blood', task: 'Avernic hilt', points: 30, xp: 10000, type: 'boss', cap: 3 },
      { tile: 'Theatre of Blood', task: 'Sanguinesti staff', points: 40, xp: 10000, type: 'boss', cap: 3 },
      { tile: 'Misc. Tasks', task: 'Champion Scroll', points: 10, xp: 5000, type: 'non-boss', cap: 3 },
      { tile: 'Callisto', task: 'Dragon pickaxe', points: 15, xp: 10000, type: 'non-boss', cap: 2 },
      { tile: 'Callisto', task: 'Bear pet', points: 25, xp: 10000, type: 'non-boss', cap: 2 }
    ];

    // Tiles
    const tiles = {
      'A1': { name: 'Abyssal Sire', points: 50 }, 'A2': { name: 'Chambers of Xeric', points: 100 },
      'A3': { name: 'Leviathan', points: 60 }, 'A4': { name: 'Theatre of Blood', points: 150 },
      'A5': { name: 'Misc. Tasks', points: 40 }, 'B1': { name: 'Duke Sucellus', points: 60 },
      'B2': { name: 'General Graardor', points: 80 }, 'B3': { name: 'Zulrah', points: 70 },
      'B4': { name: 'Whisperer', points: 80 }, 'B5': { name: 'Callisto', points: 50 },
      'C1': { name: 'Kraken', points: 50 }, 'C2': { name: 'Tombs of Amascut', points: 120 },
      'C3': { name: 'Vardorvis', points: 60 }, 'C4': { name: 'Kree\'arra', points: 80 },
      'C5': { name: 'Barrows Brothers', points: 40 }, 'D1': { name: 'Cerberus', points: 60 },
      'D2': { name: 'Phantom Muspah', points: 70 }, 'D3': { name: 'Alchemical Hydra', points: 70 },
      'D4': { name: 'Nex', points: 100 }, 'D5': { name: 'Venenatis', points: 50 },
      'E1': { name: 'Gauntlet', points: 60 }, 'E2': { name: 'Corporeal Beast', points: 80 },
      'E3': { name: 'K\'ril Tsutsaroth', points: 80 }, 'E4': { name: 'Sarachnis', points: 40 },
      'E5': { name: 'Kraken Prime', points: 400 }
    };

    // Main App Component
    function App() {
      const [state, setState] = useState(initialState);
      const [team, setTeam] = useState('Trident');
      const [role, setRole] = useState('Captain');
      const [isLeader, setIsLeader] = useState(true);
      const [playerId, setPlayerId] = useState('Player1');

      // Timer Logic
      useEffect(() => {
        const interval = setInterval(() => {
          setState(prev => {
            let { minutes, seconds, phase } = prev.timer;
            seconds--;
            if (seconds < 0) {
              seconds = 59;
              minutes--;
            }
            if (minutes === 8 && seconds === 0) phase = 'Execution';
            if (minutes === 0 && seconds === 0) {
              minutes = 10;
              seconds = 0;
              phase = 'Planning';
            }
            return { ...prev, timer: { minutes, seconds, phase } };
          });
        }, 1000);
        return () => clearInterval(interval);
      }, []);

      // Save state to localStorage
      useEffect(() => {
        localStorage.setItem('gameState', JSON.stringify(state));
      }, [state]);

      // Load state from localStorage
      useEffect(() => {
        const savedState = localStorage.getItem('gameState');
        if (savedState) setState(JSON.parse(savedState));
      }, []);

      // Add Message
      const addMessage = (message) => {
        setState(prev => ({ ...prev, messages: [...prev.messages, { team, role, playerId, message, time: new Date().toLocaleTimeString() }] }));
      };

      // Captain Dashboard
      function CaptainDashboard() {
        const move = (direction) => {
          if (!isLeader || state.timer.phase !== 'Execution') return;
          const currentTile = state.teams[team].position;
          const [row, col] = [currentTile[0], parseInt(currentTile[1])];
          let newTile;
          if (direction === 'N' && row !== 'A') newTile = String.fromCharCode(row.charCodeAt(0) - 1) + col;
          if (direction === 'S' && row !== 'E') newTile = String.fromCharCode(row.charCodeAt(0) + 1) + col;
          if (direction === 'E' && col !== 5) newTile = row + (col + 1);
          if (direction === 'W' && col !== 1) newTile = row + (col - 1);
          if (!newTile || tiles[newTile].status === 'Cleared') return;
          
          let xpCost = 20000;
          const lastMove = state.teams[team].lastMove;
          if (lastMove === direction) xpCost += 5000;
          
          if (state.teams[team].xp >= xpCost) {
            const otherTeam = team === 'Trident' ? 'Harpoon' : 'Trident';
            if (state.teams[otherTeam].position === newTile) {
              addMessage(`Conflict at ${newTile}! Waiting for Stop! resolution.`);
              return;
            }
            setState(prev => ({
              ...prev,
              teams: {
                ...prev.teams,
                [team]: { ...prev.teams[team], position: newTile, xp: prev.teams[team].xp - xpCost, lastMove: direction }
              }
            }));
            addMessage(`Moved to ${tiles[newTile].name} (${xpCost} XP)`);
          }
        };

        const stop = () => {
          if (!isLeader || state.timer.phase !== 'Execution') return;
          const otherTeam = team === 'Trident' ? 'Harpoon' : 'Trident';
          const currentTile = state.teams[team].position;
          if (state.teams[otherTeam].position === currentTile) {
            const teamXP = state.teams[team].xp;
            const otherXP = state.teams[otherTeam].xp;
            if (teamXP > otherXP) {
              setState(prev => ({
                ...prev,
                teams: {
                  ...prev.teams,
                  [otherTeam]: { ...prev.teams[otherTeam], position: prev.teams[otherTeam].lastPosition }
                }
              }));
              addMessage(`Stop! ${team} wins tile ${currentTile}.`);
            } else {
              setState(prev => ({
                ...prev,
                teams: {
                  ...prev.teams,
                  [team]: { ...prev.teams[team], position: prev.teams[team].lastPosition }
                }
              }));
              addMessage(`Stop! ${otherTeam} wins tile ${currentTile}.`);
            }
          }
        };

        const suggestMove = (direction) => {
          if (isLeader) return;
          addMessage(`Suggested move: ${direction}`);
        };

        return (
          <div className="p-4 bg-white rounded shadow">
            <h2 className="text-xl font-bold mb-4">Captains Dashboard</h2>
            <div className="grid grid-cols-5 gap-1 mb-4">
              {['A', 'B', 'C', 'D', 'E'].map(row => (
                [1, 2, 3, 4, 5].map(col => {
                  const tile = `${row}${col}`;
                  const isCurrent = state.teams[team].position === tile;
                  const isCleared = tiles[tile]?.status === 'Cleared';
                  return (
                    <div
                      key={tile}
                      className={`p-2 text-center border ${isCurrent ? 'bg-blue-500 text-white' : isCleared ? 'bg-green-500' : 'bg-gray-200'} ${tiles[tile] ? 'cursor-pointer' : ''}`}
                      onClick={() => isLeader && move(tile)}
                    >
                      {tiles[tile]?.name || ''}
                    </div>
                  );
                })
              ))}
            </div>
            <div className="flex space-x-2 mb-4">
              {isLeader && (
                <>
                  <button className="px-4 py-2 bg-blue-500 text-white rounded" onClick={() => move('N')}>North</button>
                  <button className="px-4 py-2 bg-blue-500 text-white rounded" onClick={() => move('S')}>South</button>
                  <button className="px-4 py-2 bg-blue-500 text-white rounded" onClick={() => move('E')}>East</button>
                  <button className="px-4 py-2 bg-blue-500 text-white rounded" onClick={() => move('W')}>West</button>
                  <button className="px-4 py-2 bg-red-500 text-white rounded" onClick={stop}>Stop!</button>
                </>
              )}
              {!isLeader && (
                <>
                  <button className="px-4 py-2 bg-gray-500 text-white rounded" onClick={() => suggestMove('N')}>Suggest North</button>
                  <button className="px-4 py-2 bg-gray-500 text-white rounded" onClick={() => suggestMove('S')}>Suggest South</button>
                  <button className="px-4 py-2 bg-gray-500 text-white rounded" onClick={() => suggestMove('E')}>Suggest East</button>
                  <button className="px-4 py-2 bg-gray-500 text-white rounded" onClick={() => suggestMove('W')}>Suggest West</button>
                </>
              )}
            </div>
            <p>Team XP: {state.teams[team].xp}</p>
          </div>
        );
      }

      // Weapons Officer Dashboard
      function WeaponsOfficerDashboard() {
        const assignTask = (task, member) => {
          if (!isLeader || state.timer.phase !== 'Planning') return;
          if (state.tasks.filter(t => t.team === team && t.tile === task.tile).length >= task.cap) {
            addMessage(`Task cap reached for ${task.tile}`);
            return;
          }
          setState(prev => ({
            ...prev,
            tasks: [...prev.tasks, { team, role: 'Weapons', tile: task.tile, task: task.task, points: task.points, xp: task.xp, member, status: 'Assigned' }]
          }));
          addMessage(`Assigned ${task.task} to ${member}`);
        };

        const completeTask = (task) => {
          if (isLeader || state.timer.phase !== 'Execution') return;
          setState(prev => {
            const newTasks = prev.tasks.map(t => t.task === task.task && t.member === playerId ? { ...t, status: 'Completed' } : t);
            const teamState = prev.teams[team];
            const points = task.points * (teamState.weaponsLevel >= 8 ? 2 : teamState.weaponsLevel >= 5 ? 1.5 : 1);
            const newPoints = teamState.points + points;
            const newXP = teamState.xp + task.xp;
            const tilePoints = newTasks.filter(t => t.team === team && t.tile === task.tile && t.status === 'Completed').reduce((sum, t) => sum + t.points, 0);
            const tilesCleared = tilePoints >= tiles[task.tile].points ? teamState.tilesCleared + 1 : teamState.tilesCleared;
            return {
              ...prev,
              tasks: newTasks,
              teams: {
                ...prev.teams,
                [team]: { ...teamState, points: newPoints, xp: newXP, tilesCleared, weaponsLevel: Math.min(10, Math.floor(newXP / 10000)) }
              },
              players: {
                ...prev.players,
                [playerId]: { ...prev.players[playerId], points: (prev.players[playerId]?.points || 0) + points }
              }
            };
          });
          addMessage(`${task.task} completed by ${playerId}`);
        };

        const activateWeapons = () => {
          if (!isLeader || state.timer.phase !== 'Execution') return;
          addMessage('Weapons System Activated');
        };

        return (
          <div className="p-4 bg-white rounded shadow">
            <h2 className="text-xl font-bold mb-4">Weapons Officers Dashboard</h2>
            <table className="w-full mb-4 border">
              <thead>
                <tr className="bg-gray-200">
                  <th className="p-2">Tile</th>
                  <th className="p-2">Task</th>
                  <th className="p-2">Points</th>
                  <th className="p-2">XP</th>
                  <th className="p-2">Member</th>
                  <th className="p-2">Status</th>
                  <th className="p-2">Action</th>
                </tr>
              </thead>
              <tbody>
                {state.tasks.filter(t => t.team === team && t.role === 'Weapons').map((task, idx) => (
                  <tr key={idx} className="border-b">
                    <td className="p-2">{task.tile}</td>
                    <td className="p-2">{task.task}</td>
                    <td className="p-2">{task.points}</td>
                    <td className="p-2">{task.xp}</td>
                    <td className="p-2">{task.member}</td>
                    <td className="p-2">{task.status}</td>
                    <td className="p-2">
                      {!isLeader && task.member === playerId && task.status === 'Assigned' && (
                        <button className="px-2 py-1 bg-green-500 text-white rounded" onClick={() => completeTask(task)}>Complete</button>
                      )}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
            {isLeader && (
              <div className="mb-4">
                <h3 className="text-lg font-semibold">Assign Task</h3>
                <select className="p-2 border rounded mr-2" onChange={(e) => {
                  const task = taskList.find(t => t.task === e.target.value && t.type === 'boss');
                  if (task) assignTask(task, `Player${Math.floor(Math.random() * 15) + 1}`);
                }}>
                  <option>Select Task</option>
                  {taskList.filter(t => t.type === 'boss').map(t => (
                    <option key={t.task} value={t.task}>{t.task} ({t.tile})</option>
                  ))}
                </select>
                <button className="px-4 py-2 bg-blue-500 text-white rounded" onClick={activateWeapons}>Activate Weapons</button>
              </div>
            )}
          </div>
        );
      }

      // Detection Officer Dashboard
      function DetectionOfficerDashboard() {
        const assignTask = (task, member) => {
          if (!isLeader || state.timer.phase !== 'Planning') return;
          if (state.tasks.filter(t => t.team === team && t.tile === task.tile).length >= task.cap) {
            addMessage(`Task cap reached for ${task.tile}`);
            return;
          }
          setState(prev => ({
            ...prev,
            tasks: [...prev.tasks, { team, role: 'Detection', tile: task.tile, task: 'task.task', points: task.points, xp: task.xp, member, status: 'Assigned' }]
          }));
          addMessage(`Assigned ${task.task} to ${member}`);
        };

        const completeTask = (task) => {
          if (isLeader || state.timer.phase !== 'Execution') return;
          setState(prev => {
            const newTasks = prev.tasks.map(t => t.task === task.task && t.member === playerId ? { ...t, status: 'Completed' } : t);
            const teamState = prev.teams[team];
            const points = task.points;
            const newPoints = teamState.points + points;
            const newXP = teamState.xp + task.xp;
            const tilePoints = newTasks.filter(t => t.team === team && t.tile === task.tile && t.status === 'Completed').reduce((sum, t) => sum + t.points, 0);
            const tilesCleared = tilePoints >= tiles[task.tile].points ? teamState.tilesCleared + 1 : teamState.tilesCleared;
            return {
              ...prev,
              tasks: newTasks,
              teams: {
                ...prev.teams,
                [team]: { ...teamState, points: newPoints, xp: newXP, tilesCleared, detectionLevel: Math.min(10, Math.floor(newXP / 10000)) }
              },
              players: {
                ...prev.players,
                [playerId]: { ...prev.players[playerId], points: (prev.players[playerId]?.points || 0) + points }
              }
            };
          });
          addMessage(`${task.task} completed by ${playerId}`);
        };

        const scan = () => {
          if (!isLeader || state.timer.phase !== 'Execution') return;
          const scanCost = state.teams[team].detectionLevel >= 8 ? 2000 : state.teams[team].detectionLevel >= 5 ? 5000 : 10000;
          if (state.teams[team].xp >= scanCost) {
            const otherTeam = team === 'Trident' ? 'Harpoon' : 'Trident';
            setState(prev => ({
              ...prev,
              teams: {
                ...prev.teams,
                [team]: { ...prev.teams[team], xp: prev.teams[team].xp - scanCost }
              }
            }));
            addMessage(`Scanned ${otherTeam} at ${tiles[prev.teams[otherTeam].position].name}`);
          }
        };

        const activateDetection = () => {
          if (!isLeader || state.timer.phase !== 'Execution') return;
          addMessage('Detection System Activated');
        };

        return (
          <div className="p-4 bg-white rounded shadow">
            <h2 className="text-xl font-bold mb-4">Detection Officers Dashboard</h2>
            <table className="w-full mb-4 border">
              <thead>
                <tr className="bg-gray-200">
                  <th className="p-2">Tile</th>
                  <th className="p-2">Task</th>
                  <th className="p-2">Points</th>
                  <th className="p-2">XP</th>
                  <th className="p-2">Member</th>
                  <th className="p-2">Status</th>
                  <th className="p-2">Action</th>
                </tr>
              </thead>
              <tbody>
                {state.tasks.filter(t => t.team === team && t.role === 'Detection').map((task, idx) => (
                  <tr key={idx} className="border-b">
                    <td className="p-2">{task.tile}</td>
                    <td className="p-2">{task.task}</td>
                    <td className="p-2">{task.points}</td>
                    <td className="p-2">{task.xp}</td>
                    <td className="p-2">{task.member}</td>
                    <td className="p-2">{task.status}</td>
                    <td className="p-2">
                      {!isLeader && task.member === playerId && task.status === 'Assigned' && (
                        <button className="px-2 py-1 bg-green-500 text-white rounded" onClick={() => completeTask(task)}>Complete</button>
                      )}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
            {isLeader && (
              <div className="mb-4">
                <h3 className="text-lg font-semibold">Assign Task</h3>
                <select className="p-2 border rounded mr-2" onChange={(e) => {
                  const task = taskList.find(t => t.task === e.target.value && t.type === 'non-boss');
                  if (task) assignTask(task, `Player${Math.floor(Math.random() * 15) + 1}`);
                }}>
                  <option>Select Task</option>
                  {taskList.filter(t => t.type === 'non-boss').map(t => (
                    <option key={t.task} value={t.task}>{t.task} ({t.tile})</option>
                  ))}
                </select>
                <button className="px-4 py-2 bg-blue-500 text-white rounded" onClick={scan}>Scan</button>
                <button className="px-4 py-2 bg-blue-500 text-white rounded" onClick={activateDetection}>Activate Detection</button>
              </div>
            )}
          </div>
        );
      }

      // Engineer Dashboard
      function EngineerDashboard() {
        const logPenalty = () => {
          if (!isLeader || state.timer.phase !== 'Execution') return;
          setState(prev => {
            const newHealth = Math.max(0, prev.teams[team].health - 1);
            let newTeams = { ...prev.teams, [team]: { ...prev.teams[team], health: newHealth } };
            if (newHealth